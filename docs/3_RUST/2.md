# 常用语法
学习一门语言，我们需要快速的过一下它的语法，Rust并没有在语法层面上刻意创新，而是吸收和借鉴了许多优秀的语法经验，并且很大程度上Rust语言就是围绕其类型来设计的。

Rust也是一种强类型语言，需要提前明确地写出各个函数参数类型和返回值类型。但Rust也有基本的类型推断，会帮你推断出大部分类型，可以在一定程度上省略类型。

以下便是两种写法：
```rust
fn build_vector() -> Vec<i16> {
    let mut v: Vec<i16> = Vec::<i16>::new();
    v.push(10i16);
    v.push(20i16);
}

```

上边这种语法看起来就像C++的那种又臭又长的语法，那我们可以简化为：
```rust
fn build_vector() ->Vec<i16> {
    let mut v = Vec::new();
    v.push(10);
    v.push(20);
}
```

在功能上，这两个是完全等效， 并且在编译期间便可以捕获类型错误。

Rust的常见类型有非常多，下面我们可以逐一学习。

## 1. 固定宽度的数值类型
Rust类型系统的base便是一组固定宽度的数值类型，这些类型几乎匹配了所有现代处理器在硬件直接实现的类型。

虽然说固定长度的数值类型可能会导致溢出或者精度不够，但是他们也能满足绝大多数应用程序的需求，并且比那种任意精度整数和精确有理数等表示法快几千倍。如果实在需要这种表示方法，也可以在`new crate`中找到。

rust使用**位**来表明他们的宽度，使用前缀表示他们的用途。

|大小|无符号整数|有符号整数|浮点数
|----|----|----|----|
|8|u8|i8| |
|16|u16|i16| |
|32|u32|i32|f32|
|64|u64|i64|f64|
|128|u128|i128| |
|机器字|usize|isize| |

注：在这里，机器字表示机器的位宽，也就是随着32位处理器和64位处理器的变化而变化。

### 1.1. 整型
学过计组的同学都知道，整型分为有符号和无符号。Rust使用u8类型作为字节值，例如从二进制文件或者套接字中读取数据时会产生一个u8值构成的流。

并且Rust把char和整型视为完全不同的类型，char既不是u8，也不是u32。

`usize`和`isize`更加类似于C/C++中的`size_t`,它们的精度与目标机器地址空间的大小保持一致。即在32位架构是32位长，64位架构是64位长。

Rust要求数组索引为usize值，用来表示数组或向量大小，或者某些数据结构中元素数量的值通常也是`usize`类型。

Rust中整型还可以用下边这种形式来表示：
```rust
42u8  表示整数42是u8类型
10088isize 表示10088是isize类型
```
如果整型字面量没有带类型后缀，那么Rust就会延迟确定其类型，知道找出一处足以认定其类型的使用代码。

如果有多种可选类型，那默认用`i32`，如果还是无法确定，那么久直接报错。

前缀`0x`,`0o`,`0b`分别表示16进制、8进制、2进制的字面量。

为了让长数值更加易读，可以在数字中加下划线。
```rust
9_123_456_789
```
下划线的位置是无关紧要的，同事也可以将16进制或者2进制按照4位数字而非三位数字分组。
```rust
0xffff_abcd
```

当我们想将数字转换时，可以使用`as`来将一种整型转换成另一种整型。
```rust
assert_eq!(10_i8 as u16, 10_u16);
assert_eq!(65535_u16 as i32, 65535_i32);

```

对于超出目标范围的值，会取模，对高于目标单位的值，会进行截断。

现在会有以下这种情况：
```rust
println!("{}", (-4).abs());

```

我们发现这个会直接报错，这是因为Rust在调用方法时，需要知道这个值属于哪个类型，可以将其修改为：
```rust
println!("{}", (-4_i32).abs());
println!("{}", i32::abs(-4));
```
并且需要注意的是，方法调用的优先级是高于一元前缀运算符的，也就是说：
```rust
-4_i32.abs()
(-4_i32).abs()
```
第一个会优先对4进行调用abs，再根据负号取负值。



## 函数
函数的参数有两个名词，parameters，arguments

函数签名里边必须声明每个变量的类型

```rust
fn another_function(x: u32， y: u32) {
    // ...
}
```

函数体由一系列语句组成，由一个表达式结束。
语句没有返回值，不能赋给一个变量。


函数的返回值，就是函数体里边最后一个表达式的值

```rust
fn plus_five(x: u32) -> i32 {
    x+5 // 这里没有；
}
```

## 注释
和C语言一样，有一种特别的注释是文档注释

## 控制流
if表达式允许根据条件来执行不同的代码分支arm
- 这个条件必须是bool类型 
```rust
fn main() {
    let number = 3;
    if number <= 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```

如果使用了多于1个的else if，最好使用match来重构代码。
```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
```

## 循环
Rust提供了3种循环，loop、while、for
```rust
fn main() {
    let mut = counter = 0;

    let result = loop {
        counter += 1;

        if(counter == 10) {
            break counter * 2;
        }
    };

    println!("The result is: {}", result);
}
```

```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);
        number = number - 1;
    }
    println!("down!");
}
```

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    // 用的最多
    for element in a.iter() { // 这个地方是每次引用的
        println!("the value is: {}", element);
    }
}
```
